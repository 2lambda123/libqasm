# Implementation for the abstract syntax tree node classes.
source

# Header file for the abstract syntax tree node classes.
header

// Include tree base classes.
include "cqasm-tree.hpp"
tree_namespace cqasm::tree

// Include primitive types.
include "cqasm-v2-primitives.hpp"

// Initialization function to use to construct default values for the tree base
// classes and primitives.
initialize_function cqasm::v2::primitives::initialize

// Include SourceLocation annotation object for the debug dump generator.
src_include "cqasm-annotations.hpp"
location cqasm::annotations::SourceLocation

# Namespace for the abstract syntax tree node classes.
namespace cqasm
namespace v2
namespace ast

# A scope modifier, or lack thereof.
scope_modifier {

    # Indicates the lack of a scope modifier, resulting in local scope.
    scope_local {}

    # Indicates that the "export" keyword was used, resulting in parent scope.
    scope_parent {}

    # Indicates that the "global" keyword was used, resulting in global scope.
    scope_global {}

}

# A lifetime modifier, or lack thereof.
lifetime_modifier {

    # Indicates the lack of a lifetime modifier, resulting in automatic
    # lifetime.
    lifetime_automatic {}

    # Indicates that the "static" keyword was used, resulting in static
    # lifetime.
    lifetime_static {}

}

# An implementation modifier, or lack thereof.
implementation_modifier {

    # Indicates that the compiler and/or target should choose the best available
    # implementation.
    implementation_automatic {}

    # Indicates that the associated construct must be implemented using only
    # compile-time logic. For example, functions must be inlined, expressions
    # must be inlined and constant-propagated, etc. The exact semantics depend
    # on the construct.
    implementation_inline {}

    # Indicates that the associated construct must be implemented using
    # classical ALU-based logic at runtime. This should be done even if the
    # construct would otherwise be optimized away, so this effectively inhibits
    # most optimizations.
    implementation_runtime {}

    # Indicates that the associated construct must map to an atomic machine
    # instruction. Usefulness in user code is probably limited to asserting that
    # a construct must be implemented using conditional execution, but it is
    # essential in gateset definitions in architecture-specific header files.
    implementation_primitive {}

}

# A pack of modifier keywords, or lack thereof.
modifiers {

    # Scope modifier.
    scope: One<scope_modifier>;

    # Lifetime modifier.
    lifetime: One<lifetime_modifier>;

    # Implementation style modifier.
    implementation: One<implementation_modifier>;

}

# An annotation/pragma data block.
annotation_data {

    # Interface name.
    iface: One<identifier>;

    # Operation name.
    oper: One<identifier>;

    # Arbitrary data payload.
    data: One<unit>;

}

# A set of annotations applied to a control-flow block.
annotations {

    # The annotations.
    data: Any<annotation_data>;

}

# The base element for almost everything in cQASM 2.0.
unit {

    # The null literal/void type.
    void {}

    # Any kind of literal.
    literal {

        # An integer literal.
        integer_literal {

            # The integer value as written in the source code.
            value: cqasm::v2::primitives::Str;

            # A decimal integer literal.
            decimal_integer_literal {}

            # A hexadecimal integer literal.
            hexadecimal_integer_literal {}

            # A binary integer literal.
            binary_integer_literal {}

        }

        # A real number literal.
        real_literal {

            # The real number value as written in the source code.
            value: cqasm::v2::primitives::Str;

        }

        # A string literal.
        string_literal {

            # The contents of the string literal, with escape sequences already
            # processed during parsing.
            value: cqasm::v2::primitives::Str;

        }

        # A JSON literal.
        json_literal {

            # The unparsed JSON data enclosed in {}, but otherwise as written in the
            # source code.
            value: cqasm::v2::primitives::Str;

        }

    }

    # An identifier. Can be a simple name or an operator reference.
    identifier {

        # The identifier as written in the file.
        name: cqasm::v2::primitives::Str;

    }

    # Grouping parentheses. These are meaningful to the analyzer in cQASM 2.0
    # because they are used to convert comma/semicolon-separated sequentes into
    # packs. When there is no comma or semicolon immediately within the
    # parentheses this is no-op for the analyzer, and only serves to override
    # operator precedence.
    parentheses {

        # The contained unit.
        data: One<unit>;

    }

    # Unpacking operations. Turns the embedded pack or pack of packs into a
    # comma-separated list or a semicolon-separated comma-separated list.
    unpack {

        # The contained unit.
        data: One<unit>;

        # A one-dimensional unpacking operation (* prefix).
        unpack_1d {}

        # A two-dimensional unpacking operation (** prefix).
        unpack_2d {}

    }

    # Index/slice/swizzle operator. Takes a tuple (or in some cases a pack) and
    # moves elements of it around to form a scalar or a new tuple or pack.
    index {

        # The indexed unit.
        data: One<unit>;

        # The index.
        index: One<unit>;

        # A plain index operator, where the index is a potentially
        # comma-separated list of indices mapping to the dimensions of the
        # tuple/pack, where the shape (scalar or N-dimensional tuple) of the
        # indices corresponds to the shape of the returned value.
        plain_index {}

        # A transposed index operator, where the index is a potentially comma-
        # and/or semicolon-separated list corresponding to the shape of the
        # returned value, of which each element is a scalar or 1-dimensional
        # tuple of integers that map to the dimensions of the indexed value.
        transposed_index {}

    }

    # Shorthand notation for a tuple of some finitely ordered type, representing
    # an increasing or decreasing range of subsequent values.
    range_operator {

        # The first value of the tuple.
        begin: One<unit>;

        # The last value of the tuple.
        end: One<unit>;

    }

    # A regular unary operator that simply maps to a function and is thus
    # overloadable.
    unary_operator {

        # The operand.
        operand: One<unit>;

        # Positive number operator (+x).
        positive_operator {}

        # Negative number operator (-x).
        negative_operator {}

        # Logical NOT operator (!x).
        logical_not_operator {}

        # Bitwise NOT operator (~x).
        bitwise_not_operator {}

    }

    # A regular binary operator that simply maps to a function and is thus
    # overloadable.
    binary_operator {

        # The left-hand side operand.
        lhs: One<unit>;

        # The right-hand side operand.
        rhs: One<unit>;

        # Power/exponentiation operator (x ** y).
        power_operator {}

        # Multiplication operator (x * y).
        multiply_operator {}

        # True division operator (x / y).
        true_division_operator {}

        # Euclidian division operator (x // y).
        euclidian_division_operator {}

        # Euclidian remainder/modulo operator (x % y).
        modulo_operator {}

        # Addition operator (x + y).
        addition_operator {}

        # Subtraction operator (x - y).
        subtraction_operator {}

        # Shift-left operator (x << y).
        shift_left_operator {}

        # Arithmetic shift-right operator (x >> y).
        arithmetic_shift_right_operator {}

        # Logical shift-right operator (x >>> y).
        logical_shift_right_operator {}

        # Less-than operator (x < y).
        less_than_operator {}

        # Less-than or equal operator (x <= y).
        less_or_equal_operator {}

        # Greater-than operator (x > y).
        greater_than_operator {}

        # Greater-than or equal operator (x >= y).
        greater_or_equal_operator {}

        # Equality operator (x == y).
        equality_operator {}

        # Inequality operator (x != y).
        inequality_operator {}

        # Bitwise AND operator (x & y).
        bitwise_and_operator {}

        # Bitwise XOR operator (x ^ y).
        bitwise_xor_operator {}

        # Bitwise OR operator (x | y).
        bitwise_or_operator {}

        # Logical XOR operator (x ^^ y).
        logical_xor_operator {}

    }

    # Short-circuiting operators.
    short_circuit_operator {

        # Short-circuiting logical AND operator.
        logical_and_operator {

            # The left-hand side operand.
            lhs: One<unit>;

            # The right-hand side operand, only analyzed when lhs is not
            # literal false, and only has side effects evaluated at runtime when
            # lhs did not evaluate to false.
            rhs: One<unit>;

        }

        # Short-circuiting logical OR operator.
        logical_or_operator {

            # The left-hand side operand.
            lhs: One<unit>;

            # The right-hand side operand, only analyzed when lhs is not
            # literal true, and only has side effects evaluated at runtime when
            # lhs did not evaluate to true.
            rhs: One<unit>;

        }

        # Selection ternary operator.
        selection_operator {

            # The condition operand.
            condition: One<unit>;

            # The value when condition is true. Only analyzed when condition is
            # not literal false, and only has side effects evaluated at runtime
            # when condition evaluated to true.
            when_true: One<unit>;

            # The value when condition is false. Only analyzed when condition is
            # not literal true, and only has side effects evaluated at runtime
            # when condition evaluated to false.
            when_false: One<unit>;

        }

    }

    # Assigning/mutating operators.
    assigning_operator {

        # The assignment target.
        target: One<unit>;

        # A plain assignment operator (x = y).
        assignment_operator {

            # The value to assign to target.
            value: One<unit>;

        }

        # Unary operators that assign a new value to target by mutating its
        # previous value.
        unary_mutating_operator {

            # Post-increment operator, i.e. increment target and return the old
            # value (x++).
            post_increment_operator {}

            # Post-decrement operator, i.e. decrement target and return the old
            # value (x--).
            post_decrement_operator {}

            # Pre-increment operator, i.e. increment target and return the new
            # value (++x).
            pre_increment_operator {}

            # Pre-decrement operator, i.e. decrement target and return the new
            # value (--y).
            pre_decrement_operator {}

        }

        # Binary operators that assign a new value to target by combining its
        # previous value with a second value.
        binary_mutating_operator {

            # The value used to mutate target with.
            value: One<unit>;

            # Updates target by raising it to the given power (x **= y).
            power_by_operator {}

            # Updates target by multiplying it with the given value (x *= y).
            multiply_by_operator {}

            # Updates target by true-dividing it by the given value (x /= y).
            true_divide_by_operator {}

            # Updates target by Euclidian-dividing it by the given value
            # (x //= y).
            euclidian_divide_by_operator {}

            # Updates target by taking the modulo of it and the given value
            # (x %= y).
            modulo_by_operator {}

            # Updates target by adding the given value to it (x += y).
            increment_by_operator {}

            # Updates target by subtracting the given value from it (x -= y).
            decrement_by_operator {}

            # Updates target by shifting it left by the given number of bits
            # (x <<= y).
            shift_left_by_operator {}

            # Updates target by arithmically shifting it right by the given
            # number of bits (x >>= y).
            arithmetically_shift_right_by_operator {}

            # Updates target by logically shifting it right by the given number
            # of bits (x >>>= y).
            logically_shift_right_by_operator {}

            # Updates target by applying the bitwise AND operator to its
            # previous value and the given value (x &= y).
            bitwise_and_by_operator {}

            # Updates target by applying the bitwise XOR operator to its
            # previous value and the given value (x ^= y).
            bitwise_xor_by_operator {}

            # Updates target by applying the bitwise OR operator to its
            # previous value and the given value (x |= y).
            bitwise_or_by_operator {}

        }

    }

    # A code block. Code blocks treat immediately enclosed semicolons as a
    # temporal separation of unit side effects (i.e. sequential
    # execution/issue), and immediately enclosed commas as spatial separation
    # of unit side effects (i.e. parallel execution/issue). They also support
    # labels (declaration unit) and goto units.
    block {

        # The contained unit.
        data: One<unit>;

    }

    # A function call.
    function_call {

        # A reference to the function.
        function: One<unit>;

        # The argument pack that the function is to be called with.
        arguments: One<unit>;

    }

    # A function definition or declaration.
    function {

        # The function name.
        name: One<identifier>;

        # The parameter pack that the function accepts.
        parameters: One<unit>;

        # The type that the function returns.
        return_type: One<unit>;

        # A function (forward) declaration. The function must be defined before
        # the current block is closed.
        function_declaration {}

        # A function definition.
        function_definition {

            # The modifier keywords that were applied to this function
            # definition.
            modifiers: One<modifiers>;

            # Any annotations applied to the function definition.
            annotations: One<annotations>;

            # The body of the function.
            body: One<unit>;

        }

    }

    # A variable, constant, or unit alias declaration.
    object_definition {

        # The modifier keywords that were applied to this object definition.
        modifiers: One<modifiers>;

        # The unit that describes the definition.
        data: One<unit>;

        # Definition for a mutable storage location.
        variable_definition {}

        # Definition for a storage location that cannot be (directly) assigned.
        constant_definition {}

        # Definition for a named alias to a unit.
        alias_definition {}

    }

    # Purely grammatical constructs that don't have a context-free semantical
    # definition.
    grammatical {

        # Two units separated by a colon.
        colon {

            # The unit to the left of the separating colon.
            lhs: One<unit>;

            # The unit to the right of the separating colon.
            rhs: One<unit>;

        }

        # Two units separated by a comma.
        comma {

            # The unit to the left of the separating comma.
            lhs: One<unit>;

            # The unit to the right of the separating comma.
            rhs: One<unit>;

        }

        # A unit with a comma suffix.
        trailing_comma {

            # The suffixed unit.
            data: One<unit>;

        }

        # Two units separated by a semicolon.
        semicolon {

            # The unit to the left of the separating semicolon.
            lhs: One<unit>;

            # The unit to the right of the separating semicolon.
            rhs: One<unit>;

        }

        # A unit with a semicolon suffix.
        trailing_semicolon {

            # The suffixed unit.
            data: One<unit>;

        }

    }


}


# Any root node for the AST.
root {

    # A complete program.
    program {


    }

    # Placeholder for a program with a parse error.
    erroneous_program {
        error;
    }

}
