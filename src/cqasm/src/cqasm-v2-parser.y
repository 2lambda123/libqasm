%define api.pure full
%define api.prefix {cqasm_v2}
%locations

%code requires {
    /**
     * \file
     * Parser, generated by Bison.
     */
    #include <memory>
    #include <cstdio>
    #include <cstdint>
    #include "cqasm-annotations.hpp"
    #include "cqasm-v2-ast.hpp"
    #include "cqasm-v2-parse-helper.hpp"
    using namespace cqasm::v2::ast;
    typedef void* yyscan_t;

    #define YYSTYPE CQASM_V2STYPE
    #define YYLTYPE CQASM_V2LTYPE

}

%code {
    int yylex(YYSTYPE* yylvalp, YYLTYPE* yyllocp, yyscan_t scanner);
    void yyerror(YYLTYPE* yyllocp, yyscan_t scanner, cqasm::v2::parser::ParseHelper &helper, const char* msg);
}

%code top {

    /**
     * Attaches a source location annotation object to the given node pointer.
     */
    #define ADD_SOURCE_LOCATION(v)                              \
        v->set_annotation(cqasm::annotations::SourceLocation(   \
            helper.filename,                                    \
            yyloc.first_line,                                   \
            yyloc.first_column,                                 \
            yyloc.last_line,                                    \
            yyloc.last_column))

    /**
     * Constructs an empty, new node of type T and places it into v. v is almost
     * always $$ (the result location), but it can't be made part of the
     * definition because preprocessing happens after bison's substitution.
     */
    #define NEW(v, T)           \
        v = new T();            \
        ADD_SOURCE_LOCATION(v)

    /**
     * Moves previously constructed node s into t, where s is almost always one
     * of bison's input locations ($1, $2, etc) and t is almost always $$. The
     * purpose of this over just assigning t = s is that it extends the source
     * location annotation of the object to the extents of whatever rule is
     * being matched.
     */
    #define FROM(t, s)                                                                  \
        t = s;                                                                          \
        {                                                                               \
            auto *loc = t->get_annotation_ptr<cqasm::annotations::SourceLocation>();    \
            if (!loc) {                                                                 \
                ADD_SOURCE_LOCATION(t);                                                 \
            } else {                                                                    \
                loc->expand_to_include(yyloc.first_line, yyloc.first_column);           \
                loc->expand_to_include(yyloc.last_line, yyloc.last_column);             \
            }                                                                           \
        }

}

%param { yyscan_t scanner }
%parse-param { cqasm::v2::parser::ParseHelper &helper }

/* YYSTYPE union */
%union {
    char           	*str;
    StringBuilder   *strb;
};

/* Typenames for nonterminals */
%type <strb> StringBuilder

/* FIXME: no %destructor for the new-allocated nodes above, so the parser may
    leak, especially when it recovers from an error. */

/* Version statement */
%token KW_VERSION

/* Include statement */
%token KW_INCLUDE

/* Definition and declaration keywords */
%token KW_GENERIC
%token KW_PARAMETER
%token KW_VAR
%token KW_CONST
%token KW_ALIAS
%token KW_FUNCTION
%token KW_OPERATOR
%token KW_TYPE

/* Scope modifier keywords */
%token KW_EXPORT
%token KW_GLOBAL

/* Lifetime modifier keywords */
%token KW_STATIC
%token KW_FUTURE

/* Implementation style keywords */
%token KW_INLINE
%token KW_RUNTIME
%token KW_PRIMITIVE

/* Conditional flow control keywords */
%token KW_COND
%token KW_IF
%token KW_ELIF
%token KW_ELSE
%token KW_MATCH
%token KW_WHEN

/* Looping flow control keywords */
%token KW_FOR
%token KW_FOREACH
%token KW_WHILE
%token KW_REPEAT
%token KW_UNTIL

/* Keywords for special instructions */
%token KW_SEND
%token KW_RECEIVE
%token KW_RETURN
%token KW_BREAK
%token KW_CONTINUE
%token KW_PRINT
%token KW_ABORT
%token KW_PRAGMA

/* Transposed index notation keyword */
%token KW_TRANSPOSE

/* Numeric literals */
%token <str> INT_LITERAL_DEC INT_LITERAL_HEX INT_LITERAL_BIN
%token <str> REAL_LITERAL
%token BAD_NUMBER

/* String and JSON literals */
%token STRING_OPEN STRING_CLOSE
%token JSON_OPEN JSON_CLOSE
%token <str> STRBUILD_APPEND STRBUILD_ESCAPE

/* Identifiers */
%token <str> IDENTIFIER

/* Multi-character operators */
%token INCREMENT
%token DECREMENT
%token POWER
%token INT_DIV
%token ARITH_SHR
%token LOGIC_SHR
%token SHL
%token CMP_GE
%token CMP_LE
%token CMP_EQ
%token CMP_NE
%token LOGIC_AND
%token LOGIC_XOR
%token LOGIC_OR
%token RANGE
%token ARROW

/* Mutation operators */
%token POWER_BY
%token MULTIPLY_BY
%token DIVIDE_BY
%token INT_DIV_BY
%token MODULO_BY
%token INCREMENT_BY
%token DECREMENT_BY
%token SHL_BY
%token ARITH_SHR_BY
%token LOGIC_SHR_BY
%token BITWISE_AND_BY
%token BITWISE_OR_BY
%token BITWISE_XOR_BY

/* Error marker tokens */
%token BAD_CHARACTER END_OF_FILE

/* Associativity rules for static expressions. The lowest precedence level
comes first. */
%nonassoc OPT_UNIT
%left ';'                                    /* Semicolon operator */
%nonassoc KW_VAR KW_CONST KW_ALIAS KW_TYPE   /* Definitions */
          KW_FUNCTION
%left ','                                    /* Comma operator */
%right KW_COND KW_IF KW_ELIF KW_ELSE         /* Flow-control constructs */
       KW_MATCH KW_WHEN KW_FOR KW_FOREACH
       KW_WHILE KW_REPEAT KW_UNTIL KW_SEND
       KW_RECEIVE KW_RETURN KW_BREAK
       KW_CONTINUE KW_PRINT KW_ABORT
       KW_PRAGMA
%nonassoc ARROW RETURN_TYPE                  /* Handles the SR conflicts for optional return types */
%nonassoc ':'                                /* Declaration operator */
%left ANNOT '@'                              /* Annotation operator without arguments */
%left ANNOT_ARGS                             /* Annotation operator with arguments */
%right '=' POWER_BY MULTIPLY_BY DIVIDE_BY    /* Assignments */
       INT_DIV_BY MODULO_BY INCREMENT_BY
       DECREMENT_BY SHL_BY ARITH_SHR_BY
       LOGIC_SHR_BY BITWISE_AND_BY
       BITWISE_OR_BY BITWISE_XOR_BY
%left RANGE                                  /* Range operator */
%right TERNARY                               /* Ternary conditional */
%left LOGIC_OR                               /* Logical OR */
%left LOGIC_XOR                              /* Logical XOR */
%left LOGIC_AND                              /* Logical AND */
%left '|'                                    /* Bitwise OR */
%left '^'                                    /* Bitwise XOR */
%left '&'                                    /* Bitwise AND */
%left CMP_EQ CMP_NE                          /* Equalities */
%left '>' '<' CMP_GE CMP_LE                  /* Inequalities */
%left SHL ARITH_SHR LOGIC_SHR                /* Bit shifts */
%left '+' '-'                                /* Addition/subtraction */
%left '*' '/' INT_DIV '%'                    /* Multiplication/division */
%right POWER                                 /* Power */
%right INCREMENT DECREMENT PREFIX            /* Prefix unary operators */
%left '(' '[' '{' POSTFIX                    /* Function call, indexation, postfix unary operators */

/* Misc. Yacc directives */
%error-verbose
%start Root

%%

/* Integer literals. */
IntegerLiteral  : INT_LITERAL_DEC                                               { std::free($1); }
                | INT_LITERAL_HEX                                               { std::free($1); }
                | INT_LITERAL_BIN                                               { std::free($1); }
                ;

/* Real-number literals. */
RealLiteral     : REAL_LITERAL                                                  { std::free($1); }
                ;

/* String builder. This accumulates JSON/String data, mostly
character-by-character. */
StringBuilder   : StringBuilder STRBUILD_APPEND                                 { FROM($$, $1); $$->push_string(std::string($2)); std::free($2); }
                | StringBuilder STRBUILD_ESCAPE                                 { FROM($$, $1); $$->push_escape(std::string($2)); std::free($2); }
                |                                                               { NEW($$, StringBuilder); }
                ;

/* String literal. */
StringLiteral   : STRING_OPEN StringBuilder STRING_CLOSE                        { delete $2; }
                ;

/* JSON literal. */
JsonLiteral     : JSON_OPEN StringBuilder JSON_CLOSE                            { delete $2; }
                ;

/* Optional scope modifier keyword. */
ScopeMod        : KW_EXPORT                                                     {}
                | KW_GLOBAL                                                     {}
                |                                                               {}
                ;

/* Optional lifetime modifier keyword. */
LifetimeMod     : KW_STATIC                                                     {}
                |                                                               {}
                ;

/* Optional implementation style keyword. */
ImplMod         : KW_INLINE                                                     {}
                | KW_RUNTIME                                                    {}
                | KW_PRIMITIVE                                                  {}
                |                                                               {}
                ;

/* Modifier set. Note that while not everything accepts everything, the grammar
doesn't care. This is handled during semantic analysis. */
Modifiers       : ScopeMod LifetimeMod ImplMod                                  {}
                ;

/* Identifiers. */
SimpleIdent     : IDENTIFIER                                                    { std::free($1); }
                ;

Identifier      : SimpleIdent                                                   {}
                | KW_OPERATOR '~'                                               {}
                | KW_OPERATOR '!'                                               {}
                | KW_OPERATOR '*'                                               {}
                | KW_OPERATOR POWER                                             {}
                | KW_OPERATOR '/'                                               {}
                | KW_OPERATOR INT_DIV                                           {}
                | KW_OPERATOR '%'                                               {}
                | KW_OPERATOR '+'                                               {}
                | KW_OPERATOR '-'                                               {}
                | KW_OPERATOR SHL                                               {}
                | KW_OPERATOR ARITH_SHR                                         {}
                | KW_OPERATOR LOGIC_SHR                                         {}
                | KW_OPERATOR '<'                                               {}
                | KW_OPERATOR CMP_LE                                            {}
                | KW_OPERATOR '>'                                               {}
                | KW_OPERATOR CMP_GE                                            {}
                | KW_OPERATOR CMP_EQ                                            {}
                | KW_OPERATOR CMP_NE                                            {}
                | KW_OPERATOR '&'                                               {}
                | KW_OPERATOR '^'                                               {}
                | KW_OPERATOR '|'                                               {}
                | KW_OPERATOR LOGIC_XOR                                         {}
                ;

AnnotationData  : SimpleIdent '.' SimpleIdent %prec ANNOT                       {}
                | SimpleIdent '.' SimpleIdent '(' OptUnit ')' %prec ANNOT_ARGS  {}
                ;

Annotations     : Annotations '@' AnnotationData                                {}
                |                                                               {}
                ;

ReturnType      : ARROW '(' OptUnit ')'                   %prec RETURN_TYPE     {}
                |                                         %prec RETURN_TYPE     {}
                ;

IfElif          : Modifiers KW_IF Annotations '(' Unit ')' ReturnType Unit              %prec KW_IF {}
                | IfElif KW_ELIF '(' Unit ')' Unit                                      %prec KW_ELIF {}
                ;

MatchCases      : MatchCases KW_WHEN Unit ARROW Unit                            {}
                |                                                               {}
                ;

MatchBody       : MatchCases                                                    {}
                | MatchCases KW_ELSE Unit                                       {}
                ;

LoopLabel       : '.' SimpleIdent                                               {}
                |                                                               {}
                ;

/* Units. */
OptUnit         : Unit                                      %prec OPT_UNIT      {} /* Explicit unit */
                |                                           %prec OPT_UNIT      {} /* Implicit void unit */
                ;

                /* Void unit */
Unit            : '(' ')'                                                       {}
                | '{' '}'                                                       {}

                /* Packing unit & grouping parentheses unit */
                | '(' Unit ')'                                                  {}

                /* Block unit */
                | '{' Unit '}'                                                  {}

                /* Function call, constructor etc. unit */
                | Unit '(' OptUnit ')'                                          {}

                /* Undefined-length tuple type unit */
                | Unit '[' ']'                                                  {}

                /* Indexing unit */
                | Unit '[' Unit ']'                                             {}
                | Unit '[' KW_TRANSPOSE Unit ']'                                {}

                /* Literal units */
                | IntegerLiteral                                                {}
                | RealLiteral                                                   {}
                | StringLiteral                                                 {}
                | JsonLiteral                                                   {}

                /* Reference unit */
                | Identifier                                                    {}

                /* Post-inc/dec units */
                | Unit INCREMENT                            %prec POSTFIX       {}
                | Unit DECREMENT                            %prec POSTFIX       {}

                /* Pre-inc/dec units */
                | INCREMENT Unit                            %prec PREFIX        {}
                | DECREMENT Unit                            %prec PREFIX        {}

                /* 1- and 2-dimensional unpacking units */
                | '*' Unit                                  %prec PREFIX        {}
                | POWER Unit                                %prec PREFIX        {}

                /* Unary operator units */
                | '+' Unit                                  %prec PREFIX        {}
                | '-' Unit                                  %prec PREFIX        {}
                | '~' Unit                                  %prec PREFIX        {}
                | '!' Unit                                  %prec PREFIX        {}

                /* Binary operator units */
                | Unit POWER Unit                                               {}
                | Unit '*' Unit                                                 {}
                | Unit '/' Unit                                                 {}
                | Unit INT_DIV Unit                                             {}
                | Unit '%' Unit                                                 {}
                | Unit '+' Unit                                                 {}
                | Unit '-' Unit                                                 {}
                | Unit SHL Unit                                                 {}
                | Unit ARITH_SHR Unit                                           {}
                | Unit LOGIC_SHR Unit                                           {}
                | Unit '<' Unit                                                 {}
                | Unit CMP_LE Unit                                              {}
                | Unit '>' Unit                                                 {}
                | Unit CMP_GE Unit                                              {}
                | Unit CMP_EQ Unit                                              {}
                | Unit CMP_NE Unit                                              {}
                | Unit '&' Unit                                                 {}
                | Unit '^' Unit                                                 {}
                | Unit '|' Unit                                                 {}
                | Unit LOGIC_XOR Unit                                           {}

                /* Short-circuiting operators */
                | Unit LOGIC_AND Unit                                           {}
                | Unit LOGIC_OR Unit                                            {}
                | Unit KW_WHEN Unit KW_ELSE Unit                %prec TERNARY   {}

                /* Range unit */
                | Unit RANGE Unit                                               {}

                /* Assignment units */
                | Unit '=' Unit                                                 {}
                | Unit POWER_BY Unit                                            {}
                | Unit MULTIPLY_BY Unit                                         {}
                | Unit DIVIDE_BY Unit                                           {}
                | Unit INT_DIV_BY Unit                                          {}
                | Unit MODULO_BY Unit                                           {}
                | Unit INCREMENT_BY Unit                                        {}
                | Unit DECREMENT_BY Unit                                        {}
                | Unit SHL_BY Unit                                              {}
                | Unit ARITH_SHR_BY Unit                                        {}
                | Unit LOGIC_SHR_BY Unit                                        {}
                | Unit BITWISE_AND_BY Unit                                      {}
                | Unit BITWISE_OR_BY Unit                                       {}
                | Unit BITWISE_XOR_BY Unit                                      {}

                /* Annotation units */
                | Unit '@' AnnotationData                                       {}

                /* Declaration unit */
                | Unit ':' Unit                                                 {}

                /* Conditional units */
                | IfElif                                        %prec KW_IF     {}
                | IfElif KW_ELSE Unit                           %prec KW_ELSE   {}
                | KW_COND Annotations '(' Unit ')' Unit         %prec KW_COND   {}
                | Modifiers KW_MATCH Annotations '(' Unit ')' ReturnType '{' MatchBody '}' %prec KW_MATCH  {}

                /* Looping units */
                | Modifiers KW_FOR LoopLabel Annotations '(' Unit ')' Unit %prec KW_FOR {}
                | Modifiers KW_FOREACH LoopLabel Annotations '(' Unit ')' Unit %prec KW_FOREACH {}
                | Modifiers KW_WHILE LoopLabel Annotations '(' Unit ')' Unit %prec KW_WHILE {}
                | Modifiers KW_REPEAT LoopLabel Annotations Unit KW_UNTIL '(' Unit ')' %prec KW_REPEAT {}

                /* Flow control units */
                | KW_RETURN OptUnit                         %prec KW_RETURN     {}
                | KW_BREAK                                  %prec KW_BREAK      {}
                | KW_BREAK SimpleIdent                      %prec KW_BREAK      {}
                | KW_CONTINUE                               %prec KW_CONTINUE   {}
                | KW_CONTINUE SimpleIdent                   %prec KW_CONTINUE   {}
                | KW_SEND '(' Unit ')'                      %prec KW_SEND       {}
                | KW_RECEIVE '(' Unit ')'                   %prec KW_RECEIVE    {}
                | KW_PRINT '(' Unit ')'                     %prec KW_PRINT      {}
                | KW_ABORT '(' Unit ')'                     %prec KW_ABORT      {}
                | KW_PRAGMA AnnotationData                  %prec KW_PRAGMA     {}

                /* Comma unit */
                | Unit ',' Unit                                                 {}
                | Unit ','                                                      {}

                /* Variable declaration unit */
                | Modifiers KW_VAR Unit                                         {}

                /* Constant declaration unit */
                | Modifiers KW_CONST Unit                                       {}

                /* Alias declaration unit */
                | Modifiers KW_ALIAS Unit                                       {}

                /* Function declaration & definition units */
                | KW_FUTURE KW_FUNCTION Identifier '(' OptUnit ')' ReturnType %prec KW_FUNCTION
                                                                                {}
                | Modifiers KW_FUNCTION Identifier '(' OptUnit ')' ReturnType Unit %prec KW_FUNCTION
                                                                                {}

                /* Type definition units */
                | Modifiers KW_TYPE Identifier '=' Unit '{' OptUnit '}'         {}
                | Modifiers KW_TYPE Identifier ':' Unit                         {}

                /* Semicolon unit */
                | Unit ';' Unit                                                 {}
                | Unit ';'                                                      {}

                ;

/* Toplevel. */
Root            : Unit                                                          {}
                | error                                                         {}
                ;

%%

void yyerror(YYLTYPE* yyllocp, yyscan_t unused, cqasm::v2::parser::ParseHelper &helper, const char* msg) {
    (void)unused;
    std::ostringstream sb;
    sb << helper.filename
       << ":"  << yyllocp->first_line
       << ":"  << yyllocp->first_column
       << ": " << msg;
    helper.push_error(sb.str());
}
